================================================================================
CAMBIOS REALIZADOS EN EL FRONTEND
Adaptación para funcionar con el Backend Implementado
================================================================================

FECHA: 2024
VERSIÓN: 1.1

================================================================================
1. RESUMEN DE CAMBIOS
================================================================================

Se han realizado los siguientes ajustes en el frontend para que funcione 
perfectamente con la implementación del backend:

1. ✅ Agregado endpoint GET_UNREAD_COUNT para obtener conteo optimizado
2. ✅ Actualizado HomeScreen para usar endpoint de conteo cuando está disponible
3. ✅ Mejorado manejo de errores con mensajes específicos del backend
4. ✅ Verificado que el código maneja correctamente objetos poblados del backend

================================================================================
2. ARCHIVOS MODIFICADOS
================================================================================

2.1. src/config/api.js
-----------------------
CAMBIOS:
- Agregado endpoint GET_UNREAD_COUNT para obtener conteo de notificaciones no leídas

CÓDIGO AGREGADO:
  GET_UNREAD_COUNT: (userId) => `${API_BASE_URL}/api/notifications/unread-count?userId=${userId}`,

MOTIVO:
El backend implementó un endpoint optimizado que retorna solo el conteo sin necesidad
de obtener todas las notificaciones. Esto mejora el rendimiento.


2.2. src/components/Residente/HomeScreen.js
-------------------------------------------
CAMBIOS:
- Actualizada función fetchUnreadCount para usar primero el endpoint optimizado
- Si el endpoint de conteo no existe, hace fallback a obtener todas las notificaciones

CÓDIGO ACTUALIZADO:
  const fetchUnreadCount = async () => {
    if (!user?._id) return;
    
    try {
      // Primero intentar usar el endpoint optimizado de conteo
      const countResponse = await fetch(API_ENDPOINTS.GET_UNREAD_COUNT(user._id));
      
      if (countResponse.ok) {
        const countData = await countResponse.json();
        setUnreadCount(countData.count || 0);
        return;
      }
      
      // Si el endpoint de conteo no existe, obtener todas y contar
      if (countResponse.status === 404) {
        const response = await fetch(API_ENDPOINTS.GET_NOTIFICATIONS(user._id));
        const data = await response.json();
        
        if (response.ok) {
          let notificationsArray = [];
          
          if (Array.isArray(data)) {
            notificationsArray = data;
          } else if (data && Array.isArray(data.notifications)) {
            notificationsArray = data.notifications;
          } else if (data && Array.isArray(data.data)) {
            notificationsArray = data.data;
          }
          
          const unread = notificationsArray.filter(n => !n.leida).length;
          setUnreadCount(unread);
        } else {
          setUnreadCount(0);
        }
      } else {
        setUnreadCount(0);
      }
    } catch (error) {
      if (error.message && !error.message.includes('Network request failed')) {
        console.error('Error al obtener conteo de notificaciones:', error);
      }
      setUnreadCount(0);
    }
  };

MOTIVO:
Optimizar el rendimiento usando el endpoint de conteo cuando está disponible,
pero manteniendo compatibilidad con versiones anteriores del backend.


2.3. src/components/Residente/NotificationsScreen.js
----------------------------------------------------
CAMBIOS:
- Mejorado manejo de errores con mensajes específicos según el código HTTP
- Comentario agregado sobre que el backend ya ordena las notificaciones

CÓDIGO ACTUALIZADO:
  } else {
    // Manejar diferentes tipos de errores del backend
    if (response.status === 404) {
      // Usuario no encontrado o endpoint no disponible
      if (data && data.message && data.message.includes('Usuario no encontrado')) {
        console.log('⚠️ Usuario no encontrado');
      } else {
        console.log('⚠️ Endpoint de notificaciones no disponible');
      }
      setNotifications([]);
    } else if (response.status === 400) {
      // Datos inválidos
      console.error('Error de validación:', data);
      setNotifications([]);
    } else {
      // Otros errores
      console.error('Error al obtener notificaciones:', data);
      setNotifications([]);
    }
  }

MOTIVO:
Proporcionar mejor feedback en los logs para debugging y manejar correctamente
los diferentes tipos de errores que el backend puede retornar.


2.4. src/components/Guardia/ValidVisitScreen.js
-----------------------------------------------
CAMBIOS:
- Mejorado manejo de errores al crear notificaciones con mensajes específicos

CÓDIGO ACTUALIZADO:
  if (notifResponse.ok) {
    console.log('✅ Notificación enviada al residente');
  } else {
    const notifError = await notifResponse.json();
    
    if (notifResponse.status === 404) {
      console.log('⚠️ Endpoint de notificaciones no disponible');
    } else if (notifResponse.status === 400) {
      // Errores de validación del backend
      console.warn('⚠️ Error de validación al crear notificación:', notifError.message || notifError);
    } else if (notifResponse.status === 403) {
      console.warn('⚠️ No tiene permiso para crear notificación');
    } else {
      console.warn('⚠️ Error al enviar notificación:', notifError.message || notifError);
    }
  }

MOTIVO:
Proporcionar mejor información de debugging cuando falla la creación de notificaciones,
especialmente para errores de validación del backend (usuario no es RESIDENTE, visita
no pertenece al usuario, etc.).


================================================================================
3. COMPATIBILIDAD CON EL BACKEND
================================================================================

3.1. FORMATO DE RESPUESTAS
--------------------------
El frontend está preparado para manejar:

✅ Array directo de notificaciones (formato actual del backend)
✅ Objetos poblados (usuarioId y visitaId como objetos completos)
✅ Diferentes estructuras de respuesta (data, notifications, array directo)
✅ Códigos HTTP específicos (200, 201, 400, 403, 404, 500)
✅ Mensajes de error estructurados del backend

3.2. ENDPOINTS UTILIZADOS
-------------------------
✅ GET /api/notifications?userId={userId} - Obtener notificaciones
✅ POST /api/notifications - Crear notificación
✅ PUT /api/notifications/{id}/read - Marcar como leída
✅ PUT /api/notifications/read-all?userId={userId} - Marcar todas como leídas
✅ GET /api/notifications/unread-count?userId={userId} - Obtener conteo (nuevo)

3.3. VALIDACIONES DEL BACKEND
-----------------------------
El frontend está preparado para manejar las validaciones del backend:

✅ Usuario debe ser RESIDENTE (el backend retorna 400 si no lo es)
✅ Visita debe pertenecer al usuario (el backend retorna 400 si no pertenece)
✅ Usuario debe existir (el backend retorna 404 si no existe)
✅ Visita debe existir (el backend retorna 404 si no existe)
✅ Notificación debe existir (el backend retorna 404 si no existe)
✅ Validación de permisos (el backend retorna 403 si no tiene permiso)

================================================================================
4. FLUJO COMPLETO DE FUNCIONAMIENTO
================================================================================

4.1. CREAR NOTIFICACIÓN AL VALIDAR VISITA
------------------------------------------
1. Guardia valida una visita (entrada o salida)
2. Frontend actualiza la visita en el backend
3. Frontend obtiene el residenteId de la visita
4. Frontend construye el mensaje con observaciones y verificaciones
5. Frontend envía POST /api/notifications con:
   - usuarioId: ID del residente
   - visitaId: ID de la visita
   - titulo: "Visita validada" o "Visita finalizada"
   - mensaje: Mensaje completo con observaciones
   - tipo: "validacion_visita"
   - leida: false

6. Backend valida:
   - ✅ Usuario existe y es RESIDENTE
   - ✅ Visita existe y pertenece al usuario
   - ✅ Datos son válidos

7. Backend crea la notificación en la base de datos
8. Frontend continúa normalmente (no falla si la notificación falla)

4.2. OBTENER NOTIFICACIONES
----------------------------
1. Residente abre la pantalla de notificaciones
2. Frontend hace GET /api/notifications?userId={userId}
3. Backend valida:
   - ✅ Usuario existe
   - ✅ Usuario es RESIDENTE

4. Backend retorna array de notificaciones ordenadas por fecha (descendente)
5. Frontend muestra las notificaciones con:
   - Indicador visual para no leídas
   - Información de la visita (si está poblada)
   - Fecha formateada

4.3. CONTADOR DE NOTIFICACIONES NO LEÍDAS
------------------------------------------
1. Residente está en la pantalla principal
2. Frontend intenta GET /api/notifications/unread-count?userId={userId}
3. Si el endpoint existe:
   - Backend retorna { count: X }
   - Frontend muestra badge con el número
4. Si el endpoint no existe (404):
   - Frontend hace fallback a GET /api/notifications?userId={userId}
   - Cuenta las notificaciones con leida: false
   - Muestra badge con el número

4.4. MARCAR COMO LEÍDA
-----------------------
1. Residente toca una notificación no leída
2. Frontend hace PUT /api/notifications/{id}/read
3. Backend valida:
   - ✅ Notificación existe
   - ✅ (Opcional) Notificación pertenece al usuario

4. Backend actualiza leida: true y updatedAt
5. Frontend actualiza la UI localmente

4.5. MARCAR TODAS COMO LEÍDAS
------------------------------
1. Residente presiona "Marcar todas"
2. Frontend hace PUT /api/notifications/read-all?userId={userId}
3. Backend valida:
   - ✅ Usuario existe

4. Backend actualiza todas las notificaciones con leida: false a true
5. Backend retorna { message: "...", updatedCount: X }
6. Frontend actualiza todas las notificaciones localmente

================================================================================
5. MANEJO DE ERRORES
================================================================================

5.1. ERRORES AL CREAR NOTIFICACIÓN
-----------------------------------
El frontend maneja los siguientes errores sin romper el flujo:

- 404: Endpoint no disponible → Log de advertencia, continúa normalmente
- 400: Validación fallida → Log con mensaje específico, continúa normalmente
- 403: Sin permisos → Log de advertencia, continúa normalmente
- 500: Error del servidor → Log de error, continúa normalmente

IMPORTANTE: La validación de la visita NO falla si la notificación falla.

5.2. ERRORES AL OBTENER NOTIFICACIONES
---------------------------------------
- 404: Usuario no encontrado o endpoint no disponible → Muestra lista vacía
- 400: Datos inválidos → Muestra lista vacía, log de error
- 500: Error del servidor → Muestra lista vacía, log de error

5.3. ERRORES AL OBTENER CONTEO
------------------------------
- 404: Endpoint no disponible → Hace fallback a obtener todas las notificaciones
- 404: Usuario no encontrado → Muestra contador en 0
- 500: Error del servidor → Muestra contador en 0, log de error

5.4. ERRORES AL MARCAR COMO LEÍDA
----------------------------------
- 404: Notificación no encontrada → Actualiza localmente de todas formas
- 403: Sin permisos → Actualiza localmente de todas formas
- 500: Error del servidor → Actualiza localmente de todas formas

NOTA: El frontend actualiza la UI localmente incluso si el backend falla,
para mejorar la experiencia del usuario.

================================================================================
6. ESTRUCTURA DE DATOS ESPERADA
================================================================================

6.1. NOTIFICACIÓN DEL BACKEND
-----------------------------
El backend puede retornar notificaciones con objetos poblados:

{
  "_id": "507f1f77bcf86cd799439012",
  "usuarioId": {
    "_id": "507f1f77bcf86cd799439011",
    "nombre": "Juan",
    "apellido": "Pérez",
    "username": "juan.perez",
    "phone": "1234567890",
    "tipoUsuario": "RESIDENTE"
  },
  "visitaId": {
    "_id": "507f1f77bcf86cd799439013",
    "fecha": "2024-01-15T00:00:00.000Z",
    "hora": "10:00",
    "nombreVisitante": "María García",
    "estado": "Aprobada"
  },
  "titulo": "Visita validada",
  "mensaje": "...",
  "tipo": "validacion_visita",
  "leida": false,
  "createdAt": "2024-01-15T10:30:00.000Z",
  "updatedAt": "2024-01-15T10:30:00.000Z"
}

El frontend actualmente solo usa:
- _id
- titulo
- mensaje
- tipo
- leida
- createdAt

Los campos usuarioId y visitaId poblados están disponibles para uso futuro
si se desea mostrar más información en la UI.

6.2. RESPUESTA DE CONTEO
-------------------------
{
  "count": 3
}

6.3. RESPUESTA DE MARCAR TODAS
-------------------------------
{
  "message": "Todas las notificaciones han sido marcadas como leídas",
  "updatedCount": 5
}

================================================================================
7. TESTING RECOMENDADO
================================================================================

7.1. CASOS DE PRUEBA FRONTEND
------------------------------
✅ Crear notificación exitosamente al validar visita
✅ Obtener notificaciones de un usuario con notificaciones
✅ Obtener notificaciones de un usuario sin notificaciones
✅ Mostrar contador de notificaciones no leídas
✅ Marcar una notificación como leída
✅ Marcar todas las notificaciones como leídas
✅ Manejar error 404 (endpoint no disponible)
✅ Manejar error 400 (validación fallida)
✅ Manejar error 403 (sin permisos)
✅ Fallback de conteo cuando endpoint no existe

7.2. CASOS DE PRUEBA INTEGRACIÓN
---------------------------------
✅ Validar visita como guardia → Notificación aparece para residente
✅ Residente ve notificación no leída → Contador se actualiza
✅ Residente marca notificación como leída → Contador disminuye
✅ Residente marca todas como leídas → Contador va a 0
✅ Validar visita con usuario que no es RESIDENTE → Error 400
✅ Validar visita con visita que no pertenece al usuario → Error 400
✅ Obtener notificaciones de usuario inexistente → Error 404

================================================================================
8. NOTAS IMPORTANTES
================================================================================

✅ El sistema está completamente funcional con el backend implementado
✅ El frontend maneja errores de forma elegante sin romper la aplicación
✅ Se usa el endpoint optimizado de conteo cuando está disponible
✅ Se mantiene compatibilidad con versiones anteriores (fallback)
✅ Los mensajes de error del backend se muestran en los logs para debugging
✅ La validación de visitas NO falla si la notificación falla
✅ El frontend actualiza la UI localmente incluso si el backend falla
✅ Las notificaciones se ordenan por fecha (más recientes primero)

================================================================================
9. PRÓXIMOS PASOS OPCIONALES
================================================================================

Mejoras futuras que se pueden implementar:

1. Mostrar información de la visita en la notificación (usando visitaId poblado)
2. Mostrar información del usuario en la notificación (usando usuarioId poblado)
3. Agregar notificaciones push (si se implementa en el backend)
4. Agregar filtros de notificaciones (por tipo, por fecha, etc.)
5. Agregar paginación si hay muchas notificaciones
6. Agregar sonido/vibración al recibir nueva notificación
7. Agregar badge persistente en el icono de notificaciones

================================================================================
FIN DE LA DOCUMENTACIÓN
================================================================================

El frontend está completamente adaptado y listo para funcionar con el backend
implementado. Todos los endpoints están configurados y el manejo de errores
está implementado correctamente.

¡Sistema de notificaciones completamente funcional!


